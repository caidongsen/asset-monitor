// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

/*
	Package supplychain2 is a generated protocol buffer package.

	It is generated from these files:
		api.proto

	It has these top-level messages:
		Request
		RequestOperationRecord
		Response
		ResponseException
		ResponseOK
		Receipt
		ResponseOperationRecord
		OperationRecord
		Event
		EventOperationRecord
*/
package supplychain2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MessageType int32

const (
	MessageType_MsgError           MessageType = 0
	MessageType_MsgInit            MessageType = 1
	MessageType_MsgShutDown        MessageType = 2
	MessageType_MsgClose           MessageType = 3
	MessageType_MsgOperationRecord MessageType = 4
	MessageType_MsgCount           MessageType = 5
)

var MessageType_name = map[int32]string{
	0: "MsgError",
	1: "MsgInit",
	2: "MsgShutDown",
	3: "MsgClose",
	4: "MsgOperationRecord",
	5: "MsgCount",
}
var MessageType_value = map[string]int32{
	"MsgError":           0,
	"MsgInit":            1,
	"MsgShutDown":        2,
	"MsgClose":           3,
	"MsgOperationRecord": 4,
	"MsgCount":           5,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}
func (MessageType) EnumDescriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

type Request struct {
	// Types that are valid to be assigned to Value:
	//	*Request_OperationRecord
	Value         isRequest_Value `protobuf_oneof:"value"`
	Uid           string          `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	InstructionId int64           `protobuf:"varint,3,opt,name=instructionId,proto3" json:"instructionId,omitempty"`
	Pubkey        []byte          `protobuf:"bytes,4,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	Sign          []byte          `protobuf:"bytes,5,opt,name=sign,proto3" json:"sign,omitempty"`
	ActionId      MessageType     `protobuf:"varint,6,opt,name=actionId,proto3,enum=supplychain2.MessageType" json:"actionId,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

type isRequest_Value interface {
	isRequest_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Request_OperationRecord struct {
	OperationRecord *RequestOperationRecord `protobuf:"bytes,1,opt,name=operationRecord,oneof"`
}

func (*Request_OperationRecord) isRequest_Value() {}

func (m *Request) GetValue() isRequest_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Request) GetOperationRecord() *RequestOperationRecord {
	if x, ok := m.GetValue().(*Request_OperationRecord); ok {
		return x.OperationRecord
	}
	return nil
}

func (m *Request) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *Request) GetInstructionId() int64 {
	if m != nil {
		return m.InstructionId
	}
	return 0
}

func (m *Request) GetPubkey() []byte {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

func (m *Request) GetSign() []byte {
	if m != nil {
		return m.Sign
	}
	return nil
}

func (m *Request) GetActionId() MessageType {
	if m != nil {
		return m.ActionId
	}
	return MessageType_MsgError
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Request) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Request_OneofMarshaler, _Request_OneofUnmarshaler, _Request_OneofSizer, []interface{}{
		(*Request_OperationRecord)(nil),
	}
}

func _Request_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Request)
	// value
	switch x := m.Value.(type) {
	case *Request_OperationRecord:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OperationRecord); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Request.Value has unexpected type %T", x)
	}
	return nil
}

func _Request_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Request)
	switch tag {
	case 1: // value.operationRecord
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RequestOperationRecord)
		err := b.DecodeMessage(msg)
		m.Value = &Request_OperationRecord{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Request_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Request)
	// value
	switch x := m.Value.(type) {
	case *Request_OperationRecord:
		s := proto.Size(x.OperationRecord)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RequestOperationRecord struct {
	Record        string `protobuf:"bytes,1,opt,name=record,proto3" json:"record,omitempty"`
	RecordVersion string `protobuf:"bytes,2,opt,name=recordVersion,proto3" json:"recordVersion,omitempty"`
}

func (m *RequestOperationRecord) Reset()                    { *m = RequestOperationRecord{} }
func (m *RequestOperationRecord) String() string            { return proto.CompactTextString(m) }
func (*RequestOperationRecord) ProtoMessage()               {}
func (*RequestOperationRecord) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

func (m *RequestOperationRecord) GetRecord() string {
	if m != nil {
		return m.Record
	}
	return ""
}

func (m *RequestOperationRecord) GetRecordVersion() string {
	if m != nil {
		return m.RecordVersion
	}
	return ""
}

type Response struct {
	// Types that are valid to be assigned to Value:
	//	*Response_OperationRecord
	//	*Response_Ok
	//	*Response_Exception
	Value isResponse_Value `protobuf_oneof:"value"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

type isResponse_Value interface {
	isResponse_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Response_OperationRecord struct {
	OperationRecord *ResponseOperationRecord `protobuf:"bytes,1,opt,name=operationRecord,oneof"`
}
type Response_Ok struct {
	Ok *ResponseOK `protobuf:"bytes,2,opt,name=ok,oneof"`
}
type Response_Exception struct {
	Exception *ResponseException `protobuf:"bytes,3,opt,name=exception,oneof"`
}

func (*Response_OperationRecord) isResponse_Value() {}
func (*Response_Ok) isResponse_Value()              {}
func (*Response_Exception) isResponse_Value()       {}

func (m *Response) GetValue() isResponse_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Response) GetOperationRecord() *ResponseOperationRecord {
	if x, ok := m.GetValue().(*Response_OperationRecord); ok {
		return x.OperationRecord
	}
	return nil
}

func (m *Response) GetOk() *ResponseOK {
	if x, ok := m.GetValue().(*Response_Ok); ok {
		return x.Ok
	}
	return nil
}

func (m *Response) GetException() *ResponseException {
	if x, ok := m.GetValue().(*Response_Exception); ok {
		return x.Exception
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Response) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Response_OneofMarshaler, _Response_OneofUnmarshaler, _Response_OneofSizer, []interface{}{
		(*Response_OperationRecord)(nil),
		(*Response_Ok)(nil),
		(*Response_Exception)(nil),
	}
}

func _Response_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Response)
	// value
	switch x := m.Value.(type) {
	case *Response_OperationRecord:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OperationRecord); err != nil {
			return err
		}
	case *Response_Ok:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ok); err != nil {
			return err
		}
	case *Response_Exception:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Exception); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Response.Value has unexpected type %T", x)
	}
	return nil
}

func _Response_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Response)
	switch tag {
	case 1: // value.operationRecord
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResponseOperationRecord)
		err := b.DecodeMessage(msg)
		m.Value = &Response_OperationRecord{msg}
		return true, err
	case 2: // value.ok
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResponseOK)
		err := b.DecodeMessage(msg)
		m.Value = &Response_Ok{msg}
		return true, err
	case 3: // value.exception
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResponseException)
		err := b.DecodeMessage(msg)
		m.Value = &Response_Exception{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Response_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Response)
	// value
	switch x := m.Value.(type) {
	case *Response_OperationRecord:
		s := proto.Size(x.OperationRecord)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Response_Ok:
		s := proto.Size(x.Ok)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Response_Exception:
		s := proto.Size(x.Exception)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ResponseException struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ResponseException) Reset()                    { *m = ResponseException{} }
func (m *ResponseException) String() string            { return proto.CompactTextString(m) }
func (*ResponseException) ProtoMessage()               {}
func (*ResponseException) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

func (m *ResponseException) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type ResponseOK struct {
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
}

func (m *ResponseOK) Reset()                    { *m = ResponseOK{} }
func (m *ResponseOK) String() string            { return proto.CompactTextString(m) }
func (*ResponseOK) ProtoMessage()               {}
func (*ResponseOK) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

func (m *ResponseOK) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

type Receipt struct {
	IsOk bool   `protobuf:"varint,1,opt,name=isOk,proto3" json:"isOk,omitempty"`
	Err  []byte `protobuf:"bytes,2,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *Receipt) Reset()                    { *m = Receipt{} }
func (m *Receipt) String() string            { return proto.CompactTextString(m) }
func (*Receipt) ProtoMessage()               {}
func (*Receipt) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

func (m *Receipt) GetIsOk() bool {
	if m != nil {
		return m.IsOk
	}
	return false
}

func (m *Receipt) GetErr() []byte {
	if m != nil {
		return m.Err
	}
	return nil
}

type ResponseOperationRecord struct {
	InstructionId int64  `protobuf:"varint,1,opt,name=instructionId,proto3" json:"instructionId,omitempty"`
	Event         *Event `protobuf:"bytes,2,opt,name=event" json:"event,omitempty"`
}

func (m *ResponseOperationRecord) Reset()                    { *m = ResponseOperationRecord{} }
func (m *ResponseOperationRecord) String() string            { return proto.CompactTextString(m) }
func (*ResponseOperationRecord) ProtoMessage()               {}
func (*ResponseOperationRecord) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

func (m *ResponseOperationRecord) GetInstructionId() int64 {
	if m != nil {
		return m.InstructionId
	}
	return 0
}

func (m *ResponseOperationRecord) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

type OperationRecord struct {
	Record        string `protobuf:"bytes,1,opt,name=record,proto3" json:"record,omitempty"`
	RecordVersion string `protobuf:"bytes,2,opt,name=recordVersion,proto3" json:"recordVersion,omitempty"`
}

func (m *OperationRecord) Reset()                    { *m = OperationRecord{} }
func (m *OperationRecord) String() string            { return proto.CompactTextString(m) }
func (*OperationRecord) ProtoMessage()               {}
func (*OperationRecord) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

func (m *OperationRecord) GetRecord() string {
	if m != nil {
		return m.Record
	}
	return ""
}

func (m *OperationRecord) GetRecordVersion() string {
	if m != nil {
		return m.RecordVersion
	}
	return ""
}

type Event struct {
	// Types that are valid to be assigned to Value:
	//	*Event_OperationRecord
	Value isEvent_Value `protobuf_oneof:"value"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

type isEvent_Value interface {
	isEvent_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Event_OperationRecord struct {
	OperationRecord *EventOperationRecord `protobuf:"bytes,1,opt,name=operationRecord,oneof"`
}

func (*Event_OperationRecord) isEvent_Value() {}

func (m *Event) GetValue() isEvent_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Event) GetOperationRecord() *EventOperationRecord {
	if x, ok := m.GetValue().(*Event_OperationRecord); ok {
		return x.OperationRecord
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Event) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Event_OneofMarshaler, _Event_OneofUnmarshaler, _Event_OneofSizer, []interface{}{
		(*Event_OperationRecord)(nil),
	}
}

func _Event_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Event)
	// value
	switch x := m.Value.(type) {
	case *Event_OperationRecord:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OperationRecord); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Event.Value has unexpected type %T", x)
	}
	return nil
}

func _Event_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Event)
	switch tag {
	case 1: // value.operationRecord
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EventOperationRecord)
		err := b.DecodeMessage(msg)
		m.Value = &Event_OperationRecord{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Event_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Event)
	// value
	switch x := m.Value.(type) {
	case *Event_OperationRecord:
		s := proto.Size(x.OperationRecord)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EventOperationRecord struct {
	InstructionId int64 `protobuf:"varint,1,opt,name=instructionId,proto3" json:"instructionId,omitempty"`
}

func (m *EventOperationRecord) Reset()                    { *m = EventOperationRecord{} }
func (m *EventOperationRecord) String() string            { return proto.CompactTextString(m) }
func (*EventOperationRecord) ProtoMessage()               {}
func (*EventOperationRecord) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

func (m *EventOperationRecord) GetInstructionId() int64 {
	if m != nil {
		return m.InstructionId
	}
	return 0
}

func init() {
	proto.RegisterType((*Request)(nil), "supplychain2.Request")
	proto.RegisterType((*RequestOperationRecord)(nil), "supplychain2.RequestOperationRecord")
	proto.RegisterType((*Response)(nil), "supplychain2.Response")
	proto.RegisterType((*ResponseException)(nil), "supplychain2.ResponseException")
	proto.RegisterType((*ResponseOK)(nil), "supplychain2.ResponseOK")
	proto.RegisterType((*Receipt)(nil), "supplychain2.Receipt")
	proto.RegisterType((*ResponseOperationRecord)(nil), "supplychain2.ResponseOperationRecord")
	proto.RegisterType((*OperationRecord)(nil), "supplychain2.OperationRecord")
	proto.RegisterType((*Event)(nil), "supplychain2.Event")
	proto.RegisterType((*EventOperationRecord)(nil), "supplychain2.EventOperationRecord")
	proto.RegisterEnum("supplychain2.MessageType", MessageType_name, MessageType_value)
}
func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn1, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if len(m.Uid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if m.InstructionId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.InstructionId))
	}
	if len(m.Pubkey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Pubkey)))
		i += copy(dAtA[i:], m.Pubkey)
	}
	if len(m.Sign) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sign)))
		i += copy(dAtA[i:], m.Sign)
	}
	if m.ActionId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ActionId))
	}
	return i, nil
}

func (m *Request_OperationRecord) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OperationRecord != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OperationRecord.Size()))
		n2, err := m.OperationRecord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *RequestOperationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestOperationRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Record) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Record)))
		i += copy(dAtA[i:], m.Record)
	}
	if len(m.RecordVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RecordVersion)))
		i += copy(dAtA[i:], m.RecordVersion)
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn3, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *Response_OperationRecord) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OperationRecord != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OperationRecord.Size()))
		n4, err := m.OperationRecord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Response_Ok) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ok != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ok.Size()))
		n5, err := m.Ok.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Response_Exception) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Exception != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Exception.Size()))
		n6, err := m.Exception.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *ResponseException) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseException) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *ResponseOK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseOK) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ok {
		dAtA[i] = 0x8
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Receipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Receipt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsOk {
		dAtA[i] = 0x8
		i++
		if m.IsOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Err) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Err)))
		i += copy(dAtA[i:], m.Err)
	}
	return i, nil
}

func (m *ResponseOperationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseOperationRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InstructionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.InstructionId))
	}
	if m.Event != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Event.Size()))
		n7, err := m.Event.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *OperationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Record) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Record)))
		i += copy(dAtA[i:], m.Record)
	}
	if len(m.RecordVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RecordVersion)))
		i += copy(dAtA[i:], m.RecordVersion)
	}
	return i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn8, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	return i, nil
}

func (m *Event_OperationRecord) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OperationRecord != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OperationRecord.Size()))
		n9, err := m.OperationRecord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *EventOperationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOperationRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InstructionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.InstructionId))
	}
	return i, nil
}

func encodeFixed64Api(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Api(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Request) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.InstructionId != 0 {
		n += 1 + sovApi(uint64(m.InstructionId))
	}
	l = len(m.Pubkey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ActionId != 0 {
		n += 1 + sovApi(uint64(m.ActionId))
	}
	return n
}

func (m *Request_OperationRecord) Size() (n int) {
	var l int
	_ = l
	if m.OperationRecord != nil {
		l = m.OperationRecord.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestOperationRecord) Size() (n int) {
	var l int
	_ = l
	l = len(m.Record)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.RecordVersion)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Response_OperationRecord) Size() (n int) {
	var l int
	_ = l
	if m.OperationRecord != nil {
		l = m.OperationRecord.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *Response_Ok) Size() (n int) {
	var l int
	_ = l
	if m.Ok != nil {
		l = m.Ok.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *Response_Exception) Size() (n int) {
	var l int
	_ = l
	if m.Exception != nil {
		l = m.Exception.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseException) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ResponseOK) Size() (n int) {
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	return n
}

func (m *Receipt) Size() (n int) {
	var l int
	_ = l
	if m.IsOk {
		n += 2
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ResponseOperationRecord) Size() (n int) {
	var l int
	_ = l
	if m.InstructionId != 0 {
		n += 1 + sovApi(uint64(m.InstructionId))
	}
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *OperationRecord) Size() (n int) {
	var l int
	_ = l
	l = len(m.Record)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.RecordVersion)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Event) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Event_OperationRecord) Size() (n int) {
	var l int
	_ = l
	if m.OperationRecord != nil {
		l = m.OperationRecord.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *EventOperationRecord) Size() (n int) {
	var l int
	_ = l
	if m.InstructionId != 0 {
		n += 1 + sovApi(uint64(m.InstructionId))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestOperationRecord{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Request_OperationRecord{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstructionId", wireType)
			}
			m.InstructionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstructionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pubkey = append(m.Pubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.Pubkey == nil {
				m.Pubkey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign[:0], dAtA[iNdEx:postIndex]...)
			if m.Sign == nil {
				m.Sign = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			m.ActionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionId |= (MessageType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestOperationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestOperationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestOperationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Record = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseOperationRecord{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_OperationRecord{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseOK{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Ok{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseException{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Response_Exception{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseException) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseException: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseException: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseOK) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseOK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseOK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Receipt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Receipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Receipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOk = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = append(m.Err[:0], dAtA[iNdEx:postIndex]...)
			if m.Err == nil {
				m.Err = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseOperationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseOperationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseOperationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstructionId", wireType)
			}
			m.InstructionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstructionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &Event{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Record = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventOperationRecord{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Event_OperationRecord{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOperationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOperationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOperationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstructionId", wireType)
			}
			m.InstructionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstructionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 519 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x54, 0x5d, 0x6f, 0xd3, 0x30,
	0x14, 0xad, 0xdb, 0xa5, 0x1f, 0x37, 0x65, 0x0d, 0x66, 0x2a, 0x41, 0x42, 0xa5, 0x8a, 0x86, 0xd4,
	0xed, 0xa1, 0x48, 0x45, 0xbc, 0x21, 0x21, 0x0d, 0x2a, 0x75, 0x42, 0xa5, 0x60, 0xd0, 0x9e, 0xc9,
	0xda, 0xab, 0xcc, 0xb4, 0xd8, 0xc6, 0x4e, 0x06, 0xfd, 0x27, 0xfc, 0x24, 0x1e, 0x91, 0xf8, 0x03,
	0xa8, 0xfc, 0x10, 0x90, 0xd3, 0x94, 0xae, 0x5d, 0x2a, 0xf6, 0xc0, 0xdb, 0xb5, 0x7d, 0x8e, 0x7d,
	0xee, 0xb9, 0x27, 0x81, 0x5a, 0xa8, 0x78, 0x57, 0x69, 0x19, 0x4b, 0x5a, 0x37, 0x89, 0x52, 0xb3,
	0xf9, 0xf8, 0x22, 0xe4, 0xa2, 0x17, 0xfc, 0x26, 0x50, 0x61, 0xf8, 0x29, 0x41, 0x13, 0xd3, 0xd7,
	0xd0, 0x90, 0x0a, 0x75, 0x18, 0x73, 0x29, 0x18, 0x8e, 0xa5, 0x9e, 0xf8, 0xa4, 0x4d, 0x3a, 0x6e,
	0xef, 0xb0, 0x7b, 0x95, 0xd3, 0xcd, 0xf0, 0xa3, 0x4d, 0xec, 0xa0, 0xc0, 0xb6, 0xe9, 0xd4, 0x83,
	0x52, 0xc2, 0x27, 0x7e, 0xb1, 0x4d, 0x3a, 0x35, 0x66, 0x4b, 0x7a, 0x08, 0xb7, 0xb8, 0x30, 0xb1,
	0x4e, 0xc6, 0x16, 0x76, 0x3a, 0xf1, 0x4b, 0x6d, 0xd2, 0x29, 0xb1, 0xcd, 0x4d, 0xda, 0x84, 0xb2,
	0x4a, 0xce, 0xa7, 0x38, 0xf7, 0xf7, 0xda, 0xa4, 0x53, 0x67, 0xd9, 0x8a, 0x52, 0xd8, 0x33, 0x3c,
	0x12, 0xbe, 0x93, 0xee, 0xa6, 0x35, 0x7d, 0x02, 0xd5, 0x70, 0x75, 0x59, 0xb9, 0x4d, 0x3a, 0xfb,
	0xbd, 0x7b, 0x9b, 0x72, 0x87, 0x68, 0x4c, 0x18, 0xe1, 0xbb, 0xb9, 0x42, 0xf6, 0x17, 0x7a, 0x52,
	0x01, 0xe7, 0x32, 0x9c, 0x25, 0x18, 0x9c, 0x41, 0x33, 0xbf, 0x21, 0xab, 0x42, 0xaf, 0x6d, 0xa8,
	0xb1, 0x6c, 0x65, 0x7b, 0x58, 0x56, 0x67, 0xa8, 0x0d, 0x97, 0x22, 0xeb, 0x6f, 0x73, 0x33, 0xf8,
	0x41, 0xa0, 0xca, 0xd0, 0x28, 0x29, 0x0c, 0xd2, 0x37, 0xbb, 0xac, 0x7d, 0xb8, 0x6d, 0xed, 0x92,
	0x70, 0x03, 0x6f, 0x8f, 0xa1, 0x28, 0xa7, 0xe9, 0xd3, 0x6e, 0xcf, 0xdf, 0x71, 0xcb, 0xcb, 0x41,
	0x81, 0x15, 0xe5, 0x94, 0x3e, 0x83, 0x1a, 0x7e, 0x19, 0xa3, 0xb2, 0xf4, 0xd4, 0x71, 0xb7, 0xf7,
	0x20, 0x9f, 0xd2, 0x5f, 0xc1, 0x06, 0x05, 0xb6, 0xe6, 0xac, 0xdd, 0x3a, 0x82, 0xdb, 0xd7, 0xa0,
	0xf4, 0x00, 0x1c, 0xd4, 0x5a, 0xea, 0xcc, 0xa7, 0xe5, 0x22, 0xb8, 0x0f, 0xb0, 0x16, 0x42, 0xf7,
	0x53, 0xb9, 0x16, 0x50, 0xb5, 0x92, 0x82, 0x47, 0x36, 0x77, 0x63, 0xe4, 0x2a, 0xb6, 0x53, 0xe5,
	0x66, 0xb4, 0x3a, 0x4c, 0x6b, 0x9b, 0x1c, 0xd4, 0x3a, 0x6d, 0xaf, 0xce, 0x6c, 0x19, 0x7c, 0x80,
	0xbb, 0x3b, 0xdc, 0xb9, 0x1e, 0x2a, 0x92, 0x17, 0xaa, 0x23, 0x70, 0xf0, 0x12, 0x45, 0x9c, 0x79,
	0x76, 0x67, 0xd3, 0x80, 0xbe, 0x3d, 0x62, 0x4b, 0x44, 0x30, 0x82, 0xc6, 0xff, 0x0d, 0xc3, 0x7b,
	0x70, 0xd2, 0x07, 0xe8, 0xab, 0x5d, 0x41, 0x08, 0x72, 0xe4, 0xfc, 0x3b, 0x05, 0xeb, 0xc1, 0x3c,
	0x85, 0x83, 0x3c, 0xce, 0xcd, 0xbc, 0x39, 0xfe, 0x08, 0xee, 0x95, 0xcf, 0x84, 0xd6, 0xa1, 0x3a,
	0x34, 0x51, 0xdf, 0x8e, 0xd1, 0x2b, 0x50, 0x17, 0x2a, 0x43, 0x13, 0x9d, 0x0a, 0x1e, 0x7b, 0x84,
	0x36, 0xc0, 0x1d, 0x9a, 0xe8, 0xed, 0x45, 0x12, 0xbf, 0x90, 0x9f, 0x85, 0x57, 0xcc, 0xb0, 0xcf,
	0x67, 0xd2, 0xa0, 0x57, 0xa2, 0x4d, 0xa0, 0x43, 0x13, 0x6d, 0x89, 0xf0, 0xf6, 0x56, 0x28, 0x99,
	0x88, 0xd8, 0x73, 0x4e, 0xbc, 0x6f, 0x8b, 0x16, 0xf9, 0xbe, 0x68, 0x91, 0x9f, 0x8b, 0x16, 0xf9,
	0xfa, 0xab, 0x55, 0x38, 0x2f, 0xa7, 0x3f, 0xa7, 0xc7, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe5,
	0x06, 0x4f, 0xcb, 0xa9, 0x04, 0x00, 0x00,
}
